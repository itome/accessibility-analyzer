/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package team.itome.accessibilityanalyzer

import com.github.ajalt.clikt.core.CliktCommand
import com.github.ajalt.clikt.parameters.options.option
import com.github.ajalt.clikt.parameters.options.required
import com.google.android.apps.common.testing.accessibility.framework.AccessibilityCheckPreset
import com.google.android.apps.common.testing.accessibility.framework.AccessibilityCheckResult.AccessibilityCheckResultType
import com.google.android.apps.common.testing.accessibility.framework.AccessibilityHierarchyCheck
import com.google.android.apps.common.testing.accessibility.framework.AccessibilityHierarchyCheckResult
import com.google.android.apps.common.testing.accessibility.framework.uielement.AccessibilityHierarchy
import com.google.android.apps.common.testing.accessibility.framework.uielement.proto.AccessibilityHierarchyProtos.AccessibilityHierarchyProto
import java.io.File
import java.io.FileNotFoundException
import java.util.*

fun main(args: Array<String>) = AccessibilityCheckCommand().main(args)

class AccessibilityCheckCommand : CliktCommand() {
  private val targetDir by option(
    "--target",
    help = "Target directory that contains accessibility.meta files"
  ).required()

  private val targetDirFullPath: String
    get() = targetDir.replace("~", System.getProperty("user.home"))

  override fun run() {
    val files = File(targetDirFullPath).listFiles()
      ?.filter { Regex("accessibility[0-9]+.meta").matches(it.name) }
      ?: throw FileNotFoundException("No test target file found in $targetDirFullPath")

    for (file in files) {
      val proto = file.inputStream().use { stream -> AccessibilityHierarchyProto.parseFrom(stream) }
      val hierarchy = AccessibilityHierarchy.newBuilder(proto).build()
      val results = runAccessibilityChecks(hierarchy)

      results
        .filter {
          it.type == AccessibilityCheckResultType.ERROR ||
              it.type == AccessibilityCheckResultType.WARNING
        }
        .forEach { result ->
          @Suppress("UNCHECKED_CAST")
          val checkClass = AccessibilityCheckPreset.getHierarchyCheckForClass(
            result.sourceCheckClass as Class<out AccessibilityHierarchyCheck>
          )
          println(checkClass.getTitleMessage(Locale.JAPAN))
          println(result.element)
          println(checkClass.getMessageForResult(Locale.JAPAN, result))
        }
//      .forEachIndexed { index, outputProto ->
//        val file = File(dir, "${inputFile.nameWithoutExtension}_result$index.meta")
//        file.createNewFile()
//        file.outputStream().use { outputProto.writeTo(it) }
//      }
    }
  }

  private fun runAccessibilityChecks(
    hierarchy: AccessibilityHierarchy
  ): List<AccessibilityHierarchyCheckResult> {
    return AccessibilityCheckPreset
      .getAccessibilityHierarchyChecksForPreset(AccessibilityCheckPreset.LATEST)
      .flatMap { it.runCheckOnHierarchy(hierarchy) }
  }
}
